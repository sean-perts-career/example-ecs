# Example ECS Project #

This is a demonstration project which creates an ECS cluster with EC2 workers, that deploys a simple nginx web app. Utilizing CDK development with TypeScript.

## Directory Structure ##
```
example_ecs/
├── .gitignore
├── README.md
├── app                   // Sample 'Hello-World' application
    ├── Dockerfile        // Application Dockerfile
    ├── helloworld.conf   // nginx configuration
    └── index.html        // HTML configuration
├── aws-cdk               // Top level directory to contain the CDK configuration
    ├── bin               // Contains the CDK entrypoint
        ├── infra.ts      // Entrypoint
    ├── lib               // Contains CDK library resources
        ├── context.ts    // Contains helper functions to process CDK context
        ├── ecr-stack.ts  // Contains resources for the ECR stack
        ├── ecs-stack.ts  // Contains resources for the ECS stack
        └── vpc-stack.ts  // Contains resources for the VPC stack
    ├── .prettierrc       // Code formatter 'prettier' config file
    ├── cdk.json          // Primary CDK context file
    ├── package.json      // Node.js metadata file
    ├── package-lock.json // Lock file package.json
    └── tsconfig.json     // Typescript config file
```
## Prerequisites ##
* Configure Node.js environment
  * Setup and configure node version manager: https://github.com/nvm-sh/nvm
  * Run `nvm install 22` and `nvm use 22` to install and set Node v22 (which is what was used for this project)
  * Install NPM dependencies
    * Navigate to `example-ecs/aws-cdk`
    * Run `npm install`
* Configure AWS Environment 
  * Install the AWS CLI
    * Follow these instructions: https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html
  * Configure AWS credentials
    * See: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html#cli-configure-files-format
    * Make sure to set up a profile to more easily access AWS, as the rest of this tutorial will assume a profile has been created
  * Confirm your credentials have sufficient permissions to perform the deployment 
* Configure Docker environment
  * Follow: https://docs.docker.com/engine/install/

## Deployment Procedure ##
1. Setup & connect to the ECR repository \
  a. Run `npx cdk --profile <YOUR_PROFILE> -c config=dev deploy test-dev-ecrStack` \
  b. Retrieve the stack output as shown: `test-dev-ecrStack.EcrRepoUri = <AWS_ACCOUNT_NUMBER>.dkr.ecr.<AWS_REGION>.amazonaws.com/sean-example-ecs` \
  c. Consult the AWS ECR login procedure here: https://docs.aws.amazon.com/AmazonECR/latest/userguide/docker-push-ecr-image.html \
  d. Using the endpoint provided by the stack output, login to the newly created ECR repository
2. Build & Push the Docker image \
  a. Navigate to `app` directory \
  b. Run `docker build -f Dockerfile -t <ECR_REPO>:latest .` substituting in the appropriate ECR URI \
  c. Run `docker push <ECR_REPO>:latest` substituting in the appropriate ECR URI
3. Complete the CDK deployment \
  a. Navigate to the `aws-cdk` directory \
  b. Run `npx cdk --profile <YOUR_PROFILE> -c config=dev deploy --all` \
  c. Once the deployment is underway type `y` to accept the changes for each of the two following stacks, at the end there will be an output for the ALB DNS Endpoint \
  d. Copy and paste the ALB DNS Endpoint into a browser and the nginx server display should appear

## Cleanup Procedure ##
1. Remove scale-in protection for EC2 instances apart of the ASG \
  a. Navigate to Auto Scaling Group in the AWS Console, find the ASG created from this CDK stack \
  b. Navigate to instance management and select all instances \
  c. Then click `Actions` => `Remove scale-in protection`
2. Teardown the CDK stacks \
  a. In the AWS console, navigate to the Auto Scaling Groups. 
  b. Run `npx cdk --profile <YOUR_PROFILE> -c config=dev deploy --all` \
3. Delete ECR Repository \
  a. In the AWS console, navigate to ECR \
  b. Delete the CDK created ECR repository 

## Project Features ##
* Typescript code formatter configured, to run navigate to the `aws-cdk` directory and run `npm run pretty-format` which will invoke the prettier code formatter
* Coupled CDK context in a loader function, which allows specific parts of the cdk.json to be slurped into an object, ready to be referenced. That is what the `config` context variable selects.
* Logically broken the infrastructure pieces into separate stacks for increased maintainability

## Considerations & Limitations ##
* I experienced weird naming conflicts with the autogenerated name for the AsgCapacityProvider, I found this relevant issue: https://github.com/aws/aws-cdk/issues/29151
* I had to take action in the teardown process, as the ASG is configured to protect its instances from scale-in. It seems there is a disconnect with the ECS constructs as they are not properly releasing the ASG instances. I found this open issue: https://github.com/aws/aws-cdk/issues/18179
* In addition the ECR is not cleanup up automatically, its possible there is a way to configure to delete on Stack deletion, however I did not look into it
* I dont prefer using the AWS CDK over something like Terraform, the CDK has some significant drawbacks in my opinion. There is 

## Possible Enhancements ##
* Migrating the CDK context management to another approach, perhaps using a dynamically generated context
* Setting up an actual CI/CD pipeline would make orchestrating vastly easier

## Architecture ##
* ECR Stack
  * Creates the ECR repository used to house the container images used in the application deployment
  * ECR URI is outputted so that the user can more easily access the container repo
* VPC Stack
  * Creates VPC with specified number of public and private subnets
  * VPC construct is exported for use in the subsequent stacks
* ECS Stack
  * Primary stack, which configures:
    * Auto Scaling Group, which utilizes ECS optimized AMIs for the EC2 instances
    * ECS Resources, including the ECS cluster, CapacityProvider, Service, Task/Container Definitions
    * ALB Resources, including the listener and target groups
    * This is also where we connect the ECS Service with the ALB Config

## Other Useful Commands ##
* `npm run build`   compile typescript to js
* `npm run watch`   watch for changes and compile
* `npx cdk diff`    compare deployed stack with current state
* `npx cdk synth`   emits the synthesized CloudFormation template
